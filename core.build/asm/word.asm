; **** generated by scanner.py ****


; ***** con.clear.screen *****

word_def__word_63_6f_6e_2e_63_6c_65_61_72_2e_73_63_72_65_65_6e:
        call     IOClearScreen
        ret

; ***** con.copy *****

word_def__word_63_6f_6e_2e_63_6f_70_79:
        push     de
        push     hl
        push     ix
        push     hl                                     ; HL -> IX
        pop     ix
        ld         e,(ix+0)                            ; DE = memory
        ld         d,(ix+1)
        ld         l,(ix+2)                            ; HL = position
        ld         h,(ix+3)
        ld         c,(ix+4)                            ; BC = count
        ld         b,(ix+5)
__concopy1:
        ld         a,b                                 ; finished
        or         c
        jr         z,__concopy2
        dec     bc
        ld         a,(de)
        call    IOWriteCharacter
        inc     hl
        inc     de
        jr         __concopy1
__concopy2:
        pop     ix
        pop     hl
        pop     de
        ret

; ***** con.inkey *****

word_def__word_63_6f_6e_2e_69_6e_6b_65_79:
        ex         de,hl
        call     IOScanKeyboard
        ld         l,a
        ld         h,0
        ret

; ***** con.cursor! *****

word_def__word_63_6f_6e_2e_63_75_72_73_6f_72_21:
        jp         IOSetCursor
        ret

; ***** con.screen! *****

word_def__word_63_6f_6e_2e_73_63_72_65_65_6e_21:
        ld         a,e
        jp         IOWriteCharacter
        ret

; ***** and *****

word_def__word_61_6e_64:
        ld         a,h
        and     d
        ld         h,a
        ld         a,l
        and     e
        ld         l,a
        ret

; ***** max *****

word_def__word_6d_61_78:
        xor     a                                    ; clear carry
        sbc     hl,de                                 ; subtract for comparison
        ld      a,h                                 ; preserve MSB in A for sign bit
        add     hl,de                                 ; fix values back.
        bit     7,a                                 ; check bit 7
        ret     z                                     ; if unsigned HL is largest
        ld         h,d                                 ; otherwise DE is largest
        ld         l,e
        ret

; ***** min *****

word_def__word_6d_69_6e:
        xor     a                                    ; clear carry
        sbc     hl,de                                 ; subtract for comparison
        ld      a,h                                 ; preserve MSB in A for sign bit
        add     hl,de                                 ; fix values back.
        bit     7,a                                 ; check bit 7
        ret     nz                                     ; if unsigned HL is smallest
        ld         h,d                                 ; otherwise DE is smallest
        ld         l,e
        ret

; ***** mod *****

word_def__word_6d_6f_64:
        push         de                             ; save DE (B)
        call         DivideMod16                 ; DE = result, HL = mod
        pop         de                             ; restore DE
        ret

; ***** or *****

word_def__word_6f_72:
        ld         a,h
        or         d
        ld         h,a
        ld         a,l
        or         e
        ld         l,a
        ret

; ***** / *****

word_def__word_2f:
        push         de                             ; save DE (B)
        call         DivideMod16                 ; DE = result, HL = mod
        ex             de,hl                         ; result in HL
        pop         de                             ; restore DE
        ret

; ***** = *****

word_def__word_3d:
        ld         a,h
        cp         d
        jr         nz,SetFalse
        ld         a,l
        cp         e
        jr         nz,SetFalse
SetTrue:
        ld         hl,$FFFF
        ret
SetFalse:
        ld         hl,$0000
        ret

; ***** > *****

word_def__word_3e:
__Greater:
        xor     a                                    ; clear carry
        sbc     hl,de                                 ; subtract for comparison
        ld      a,h                                 ; preserve MSB in A for sign bit
        add     hl,de                                 ; fix values back.
        bit     7,a                                 ; check bit 7
        jr         nz,SetTrue
        jr         SetFalse
        ret

; ***** >= *****

word_def__word_3e_3d:
        ld         a,h
        cp         d
        jr         nz,__Greater
        ld         a,l
        cp         e
        jr         nz,__Greater
        jr         SetTrue
        ret

; ***** < *****

word_def__word_3c:
        ld         a,h
        cp         d
        jr         nz,__LessEqual
        ld         a,l
        cp         e
        jr         nz,__LessEqual
        jr         SetFalse
        ret

; ***** <= *****

word_def__word_3c_3d:
__LessEqual:
        xor     a                                    ; clear carry
        sbc     hl,de                                 ; subtract for comparison
        ld      a,h                                 ; preserve MSB in A for sign bit
        add     hl,de                                 ; fix values back.
        bit     7,a                                 ; check bit 7
        jr         z,SetTrue
        jr         SetFalse
        ret

; ***** <> *****

word_def__word_3c_3e:
        ld         a,h
        cp         d
        jr         nz,SetTrue
        ld         a,l
        cp         e
        jr         nz,SetTrue
        jr         SetFalse
        ret

; ***** xor *****

word_def__word_78_6f_72:
        ld         a,h
        xor     d
        ld         h,a
        ld         a,l
        xor     e
        ld         l,a
        ret

; ***** -! *****

word_def__word_2d_21:
        ld         a,(hl)
        sub     e
        ld         (hl),a
        inc     hl
        ld         a,(hl)
        sbc     a,d
        ld         (hl),a
        ret

; ***** +! *****

word_def__word_2b_21:
        ld         a,(hl)
        add     a,e
        ld         (hl),a
        inc     hl
        ld         a,(hl)
        adc     a,d
        ld         (hl),a
        ret

; ***** copy *****

word_def__word_63_6f_70_79:
        push     de                                     ; save regs
        push     hl
        push     ix
        push     hl                                     ; put HL in IX
        pop     ix
        ld         c,(ix+4)                            ; count to BC
        ld         b,(ix+5)
        ld        a,b                                 ; exit if zero
        or         c
        jr         z,__copy1
        ld         l,(ix+0)                            ; HL = source
        ld         h,(ix+1)
        ld         e,(ix+2)                            ; DE = target
        ld        d,(ix+3)
        ldir                                         ; and copy.
__copy1:
        pop     ix
        pop     hl
        pop        de
        ret

; ***** fill *****

word_def__word_66_69_6c_6c:
        push     de
        push     hl
        ld         a,(hl)                                ; byte in A
        inc     hl
        inc     hl
        ld         e,(hl)                                ; target into DE temporarily
        inc     hl
        ld         d,(hl)
        inc     hl
        ld         c,(hl)                                ; count into BC
        inc     hl
        ld         b,(hl)
        ex         de,hl                                ; target in HL now
        ld         e,a                                 ; byte in E
__fill1:
        ld         a,b                                 ; finished
        or         c
        jr         z,__fill2
        dec     bc
        ld         (hl),e
        inc     hl
        jr         __fill1
__fill2:
        pop     hl
        pop     de
        ret

; ***** debug *****

word_def__word_64_65_62_75_67:
        push     de
        push     hl
        push     de
        ex         de,hl
        ld         hl,23+23*32
        call     IODisplayHexInteger
        pop     de
        ld         hl,28+23*32
        call     IODisplayHexInteger
        pop     hl
        pop     de
        ret

; ***** macro.expand *****

word_def__word_6d_61_63_72_6f_2e_65_78_70_61_6e_64:
MacroExpander:
        pop     hl                                     ; HL = code address, A = count to write
        ret

; ***** sys.info *****

word_def__word_73_79_73_2e_69_6e_66_6f:
__sysInfo:
        jr         __sysInfoExecute
        org     __sysInfo+4
SIDictionaryBase:
        dw         DictionaryBase                         ; +4,+5 start of dictionary
SIDictionaryNextFree:
        dw         DictionaryBase                        ; +6,+7 current next free dictionary byte
SIProgramNextFree:
        dw         ProgramFree                            ; +8,+9 current next free program byte
SIProgramNextFreePage:
        db         0,$FF                                ; +10     current next free program page
SIDictionaryOriginalNextFree:
        dw         DictionaryBase                        ; +12,+13 cold start next free dictionary byte
SIProgramOriginalNextFree:
        dw         ProgramFree                            ; +14,+15 cold start next free program byte
SIProgramOriginalNextFreePage:
        db         0,$FF                                ; +16     current next free program page
SIDictionaryMarkNextFree:
        dw         DictionaryBase                        ; +18,+19 mark next free dictionary byte
SIProgramMarkNextFree:
        dw         ProgramFree                            ; +20,+21 mark next free program byte
SIProgramMarkNextFreePage:
        db         0,$FF                                ; +22     mark next free program page
SIRuntimeAddress:
        dw         HaltProcessor                         ; +24,+25 run address of program.
SIStack:
        dw         StackTop                            ; +26,+27 initial stack value
__sysInfoExecute:
        ex         de,hl
        ld         hl,__sysInfo
        ret

; ***** 0= *****

word_def__word_30_3d:
        ld         a,h
        or         l
        ld         hl,$0000
        ret     nz
        dec     hl
        ret

; ***** 0< *****

word_def__word_30_3c:
        bit     7,h
        ld         hl,$0000
        ret     z
        dec     hl
        ret

; ***** 0- *****

word_def__word_30_2d:
__Negate:
        ld         b,h                                 ; BC = A
        ld         c,l
        xor     a                                     ; CCF
        ld         h,a                                 ; HL = 0
        ld         l,a
        sbc     hl,bc                                 ; subract
        ret

; ***** abs *****

word_def__word_61_62_73:
        bit     7,h
        ret        z
        jr         __Negate
        ret

; ***** not *****

word_def__word_6e_6f_74:
        ld         a,h
        cpl
        ld         h,a
        ld         a,l
        cpl
        ld        l,a
        ret

; ***** parse.buffer *****

word_def__word_70_61_72_73_65_2e_62_75_66_66_65_72:
        ex         de,hl
        ld         hl,editBuffer
        ret

; ***** parse.fetch *****

word_def__word_70_61_72_73_65_2e_66_65_74_63_68:
        xor     a                                         ; empty the parsed word buffer
        ld         (parsedWord),a                             ; now contains a NULL string.
        ex         de,hl                                     ; it's a loader so A->B first.
pf_SkipSpaces:
        call    pf_GetCharacter                         ; read character
        ld         hl,0                                     ; return 0 if CS e.g. reached buffer end.
        ret     c
        ld         b,a                                     ; save it temp.
        and     $3F                                     ; if space
        cp        ' '
        jr         z,pf_SkipSpaces                         ; go back.
        ld         hl,parsedWord+1                         ; HL now points to current word.
pf_WriteCharacter:
        ld         (hl),b                                     ; write word out.
        inc     hl
        ld         a,(parsedWord)                            ; increment the count
        inc     a
        ld         (parsedWord),a
        call     pf_GetCharacter                         ; get the next
        jr         c,pf_Exit                                 ; exit if CS (end of buffer)
        ld         b,a                                     ; save in B
        and     $3F                                     ; go back if not space
        cp         ' '
        jr         nz,pf_WriteCharacter
pf_Exit:
        ld         hl,parsedWord                             ; return A = parsedWord
        ret
pf_GetCharacter:
        push     hl
        ld         hl,(parsePointer)                        ; get current pointer
        ld         a,l                                     ; check if not reached buffer end.
        cp         editBufferEnd & 0xFF
        jr         nz,pf_NotEndBuffer
        ld         a,h
        cp         editBufferEnd / 256
        jr         nz,pf_NotEndBuffer
        pop     hl                                         ; reached end of buffer
        scf                                             ; so return with CS
        ret
pf_NotendBuffer:
        xor     a                                         ; clears carry
        ld         a,(hl)                                     ; read character
        inc     hl                                         ; bump pointer and write back
        ld         (parsePointer),hl
        pop     hl                                         ; restore HL
        ret

; ***** parse.find *****

word_def__word_70_61_72_73_65_2e_66_69_6e_64:
        push     de
        push     hl
        push     ix
        ld         (pfi_testWord),hl                        ; save address of checked word.
        ld         hl,$0000                                 ; clear result
        ld         (pfi_testResult),hl
        ld         ix,(SIDictionaryBase)                     ; start with dictionary base
pfi_MainLoop:
        ld         a,(ix+0)                                 ; reached the end (offset == 0)
        or         a
        jr         z,pfi_Exit
        ld         hl,(pfi_testWord)                         ; word to check against
        ld         a,(ix+4)                                 ; read length of dictionary word
        and     $1F
        cp         (hl)                                     ; same as length of checking word.
        call     z,pfi_TestText
        ld         c,(ix+0)                                 ; BC is offset to next
        ld         b,0
        add     ix,bc
        jr         pfi_MainLoop
pfi_Exit:
        pop     ix                                         ; restore IX and exit with result.
        pop     hl
        pop     de
        ld         hl,(pfi_testResult)                        ; unary op so A->A
        ret
pfi_TestText:
        ld         b,(hl)                                     ; put count to check into B
        push     ix                                         ; put address of entry into DE
        pop     de
        inc     de                                         ; point to fourth offset (e.g. one short)
        inc        de
        inc     de
        inc     de
pfi_TestLoop:
        inc     de                                         ; bump both pointers
        inc     hl
        ld         a,(hl)                                     ; get byte from buffer
        and     $3F                                     ; only interested in lower 6 bits
        ld         c,a
        ld         a,(de)                                     ; get byte from dictionary
        cp         c                                         ; are they the same
        ret     nz                                         ; exit if false
        djnz     pfi_TestLoop                             ; do required number of word times.
        ld         (pfi_testResult),ix                     ; all done update result.
        ret
pfi_testWord:                                            ; word being checked
        dw         0
pfi_testResult:                                            ; final result
        dw         0
        ret

; ***** parse.reset *****

word_def__word_70_61_72_73_65_2e_72_65_73_65_74:
        push    hl
        ld         hl,editBuffer
        ld         (parsePointer),hl
        pop     hl
        ret
