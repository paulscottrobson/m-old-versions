// *****************************************************************************
// *****************************************************************************
//
//		Name:		editor.m12
//		Purpose:	M12 Text and Colour Editor
//		Author:		paul@robsons.org.uk
//		Date:		30th July 2018
//
// *****************************************************************************
// *****************************************************************************

variable:editor.source 	 										// editor source memory
variable:editor.position  										// offset on screen
variable:editor.size  											// editor buffer size

variable:editor.cursor  										// cursor position.
variable:editor.key  											// current key

variable:editor.copy.from  										// for copy
variable:editor.copy.to 
variable:editor.copy.count 

//
//		Current position in memory
//
:editor.mem.pos private
	push.ab
	edit.buffer editor.cursor@ +
	pop.bb
;
//
//		Multiply by 32
//
:32* 2* 2* 2* 2* 2* ; private

//
//		Refresh whole display
//
:editor.refresh private
	editor.cursor@ 0 max editor.size@ 1- min editor.cursor!		// Force position into range
	editor.position@ + con.cursor!  							// Move position into range
	editor.source con.copy										// Screen copy
;

// *****************************************************************************
//							Clear the editor buffer
// *****************************************************************************

:editor.clear 
	push.ab
		512 for
			edit.buffer + $20 swap c!
		next 
	pop.ab
;

//
//		Check if a key was pressed
//
:editor.check.key private
	editor.key@ = 
;
//
//		Check cursor key
//
:editor.check.cursor.keys private
	20 editor.check.key if -1 editor.cursor +! then
	21 editor.check.key if -32 editor.cursor +! then
	22 editor.check.key if 32 editor.cursor +! then
	23 editor.check.key if 1 editor.cursor +! then
;
//
//		Put key in memory
//
:editor.insert.char private 
	editor.size@ editor.cursor@ - 					// chars to move
	for
		swap editor.mem.pos + 						// byte to shift
		a>b c@ swap 1+ c! 							// shift it up one.
	next

	editor.key@ $3F and a>r 							// char
	editor.mem.pos c@ $C0 and 						// colour of current
	r>a + 											// combine
	swap editor.mem.pos c! 							// write
	1 editor.cursor +!								// move right
;
//
//		Write spaces surrounding the buffer, used for recolour and delete
//	
:editor.space.ends private
	32 edit.buffer 1- c! 							// before
	edit.buffer editor.size@ + $20 swap c!			// after
;
//
//		Backspace
//
:editor.backspace private
	editor.cursor@ 0= if ; then 					// can't do it from position 0
	-1 editor.cursor +! 							// backspace
	editor.space.ends
	editor.mem.pos editor.copy.to! 1+ editor.copy.from! // set up to/from
	editor.size@ editor.cursor@ - editor.copy.count!   // number to count
	editor.copy.from copy 							// block copy
;

variable:editor.repaint.colour 						// repaint upper 2 bits
variable:editor.repaint.direction  					// direction of repaint scan.

//
//			Scan repaint in current direction
//
:editor.repaint.scan private
	editor.repaint.direction!							// save direction
	editor.space.ends 									// make sure space on either end
	editor.mem.pos swap									// start here
	begin
		swap
		a>r c@ $3F and editor.repaint.colour@ + r>a c!	// repaint current square
		editor.repaint.direction@ + 					// move.
		a>r c@ $3F and $20 = r>a swap 					// get test for space, preserving addr
	until
;

//
//			Repaint word in current position.
//
:editor.repaint private
	editor.key@ 3 and 2* 2* 2* 2* 2* 2* editor.repaint.colour!
	1 editor.repaint.scan -1 editor.repaint.scan
;

// *****************************************************************************
//				  Edit buffer. A is the height, B the position.
// *****************************************************************************

:editor.edit
	32* editor.size!									// Store size, position and buffer
	swap 32* editor.position!
	edit.buffer editor.source!
	begin
		editor.refresh 									// repaint
		con.getkey editor.key!							// get key
		editor.key@ 32 >= if editor.insert.char then 	// handle 32 +
		editor.check.cursor.keys						// check cursor keys
		8 editor.check.key if editor.backspace then 	// check for delete
		editor.key@ 2/ 2/ 4 = if editor.repaint then 	// repaint
		13 editor.check.key 							// check for return
	until 
;
